package se.kth.ics.pwnpr3d.layer2.software;

import se.kth.ics.pwnpr3d.datatypes.ImpactType;
import se.kth.ics.pwnpr3d.layer1.Vulnerability;

// TODO ! ! Distinguish between local, adjacent network and network
// TODO ! ! Distinguish between authenticated an unauthenticated.
// TODO ! ! Where do we specify who has access to this vulnerability?
// TODO ! ! Generate test cases for this vulnerability

//TODO ! ! Distinguish between local, adjacent network and network
//TODO ! ! Generate test cases for this vulnerability

//There may be at least 6 cases: local-authenticated, adjacent-authenticated, network-authenticated, etc.
//Each case has a different distribution wrt at least discovery, but perhaps also the other steps.
//Therefore, it should be possible to provide these distributions based on, e.g. the NVD
//We could specialize a function, localTTC_CWE119(cpe, attackVector, authentication, conf-impact, int_imp, aval_imp)
//But we also need different outcomes, so readData has one localTTC and spoofIdentity ha another.

//TTC(conf | CWE199, mac_os_x, authenticated, local) = p(conf | CWE119)p(CWE119 | mac_os_x)Gamma(k, theta_mac)
//TTC(integr | CWE199, mac_os_x) = p(integr | CWE119)p(CWE119 | mac_os_x)Gamma(k, theta_mac)
//TTC(avail | CWE199, mac_os_x) = p(avail | CWE119)p(CWE119 | mac_os_x)Gamma(k, theta_mac)

// we would like to have different probs if the attacker has root. In an
// attack graph, that would be easily represented, but how now?
//
// From the model: cpe, available attack vector, authentication
// To the model: TTC for data read, data write, service.dos,
// identity.spoof
// It seems attractive to have one vuln per CWE
// Because available attack vector and auth is a function of the attack
// path, we need to specify each option statically.
// Thus, there should be one path for the authentcated user, and another
// for the unauth.
// There should also be one path for each vector, so there should be six
// ways to exploit.
// If exploit is successful, then there are new probs for each
// consequence.
// This results in an attack graph where six nodes lead to one leads to
// three to six.
//
// confTheta = theta_mac_os_x * p_conf *
// intgrTheta = y

public class SoftwareVulnerability extends Vulnerability {

   public SoftwareVulnerability(String name, Software superAsset, ImpactType impact) {
      super(name, superAsset, impact);
      spoofedIdentities.add(superAsset.getAdministrator());
      //     superAsset.getUser().addVulnerability(this);
      superAsset.getGuest().addVulnerability(this);
   }

   public SoftwareVulnerability(String name, Software superAsset) {
      super(name, superAsset);
   //   spoofedIdentities.add(superAsset.getAdministrator());
      //     superAsset.getUser().addVulnerability(this);
   //   superAsset.getGuest().addVulnerability(this);
   }

}
